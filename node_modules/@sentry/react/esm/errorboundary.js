import { __assign, __extends } from "tslib";
import * as Sentry from '@sentry/browser';
import * as hoistNonReactStatic from 'hoist-non-react-statics';
import * as React from 'react';
export var UNKNOWN_COMPONENT = 'unknown';
var INITIAL_STATE = {
    componentStack: null,
    error: null,
};
/**
 * A ErrorBoundary component that logs errors to Sentry.
 * Requires React >= 16
 */
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = INITIAL_STATE;
        _this.resetErrorBoundary = function () {
            var onReset = _this.props.onReset;
            if (onReset) {
                onReset(_this.state.error, _this.state.componentStack);
            }
            _this.setState(INITIAL_STATE);
        };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, _a) {
        var componentStack = _a.componentStack;
        var eventId = Sentry.captureException(error, { contexts: { react: { componentStack: componentStack } } });
        var _b = this.props, onError = _b.onError, showDialog = _b.showDialog, dialogOptions = _b.dialogOptions;
        if (onError) {
            onError(error, componentStack);
        }
        if (showDialog) {
            Sentry.showReportDialog(__assign(__assign({}, dialogOptions), { eventId: eventId }));
        }
        // componentDidCatch is used over getDerivedStateFromError
        // so that componentStack is accessible through state.
        this.setState({ error: error, componentStack: componentStack });
    };
    ErrorBoundary.prototype.componentDidMount = function () {
        var onMount = this.props.onMount;
        if (onMount) {
            onMount();
        }
    };
    ErrorBoundary.prototype.componentWillUnmount = function () {
        var _a = this.state, error = _a.error, componentStack = _a.componentStack;
        var onUnmount = this.props.onUnmount;
        if (onUnmount) {
            onUnmount(error, componentStack);
        }
    };
    ErrorBoundary.prototype.render = function () {
        var fallback = this.props.fallback;
        var _a = this.state, error = _a.error, componentStack = _a.componentStack;
        if (error) {
            if (React.isValidElement(fallback)) {
                return fallback;
            }
            if (typeof fallback === 'function') {
                return fallback({ error: error, componentStack: componentStack, resetError: this.resetErrorBoundary });
            }
            // Fail gracefully if no fallback provided
            return null;
        }
        return this.props.children;
    };
    return ErrorBoundary;
}(React.Component));
function withErrorBoundary(WrappedComponent, errorBoundaryOptions) {
    var componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;
    var Wrapped = function (props) { return (React.createElement(ErrorBoundary, __assign({}, errorBoundaryOptions),
        React.createElement(WrappedComponent, __assign({}, props)))); };
    Wrapped.displayName = "errorBoundary(" + componentDisplayName + ")";
    // Copy over static methods from Wrapped component to Profiler HOC
    // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over
    hoistNonReactStatic(Wrapped, WrappedComponent);
    return Wrapped;
}
export { ErrorBoundary, withErrorBoundary };
//# sourceMappingURL=errorboundary.js.map